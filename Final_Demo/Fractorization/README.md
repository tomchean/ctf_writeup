# Fractorization

In the challenge, we get the four files: [encryption code](enc.py), [public key](pub.der), [encrypted private key](priv.der.enc) and [encrypted flag](flag.enc)

From [encryption code](enc.py),
```python
from Crypto.Cipher import AES
from Crypto.PublicKey import RSA
from secrets import my_rsa_key_generator, key, flag

def pad(data):
  pad_size = AES.block_size - len(data) % AES.block_size
  return data + pad_size * bytes([pad_size])

n, e, d, p, q = my_rsa_key_generator(nbits = 4096)
rsa_key = RSA.construct((n, e, d, p, q))

pub_der = rsa_key.publickey().exportKey('DER')
priv_der = rsa_key.exportKey('DER')

# AES-ECB is safe, right? :)
aes_ecb = AES.new(key, AES.MODE_ECB)
priv_der_enc = aes_ecb.encrypt(pad(priv_der))
flag_enc = rsa_key.encrypt(flag, None)[0]

open('pub.der', 'wb').write(pub_der)
open('priv.der.enc', 'wb').write(priv_der_enc)
open('flag.enc', 'wb').write(flag_enc)
```
we can find that:
* RSA keypair is generated in some secret way
* Private RSA key is encrypted through AES-ECB
* Flag is encrypted using public RSA key

According to above three key point, it is easily to know that we need to recover the private key from the public key and the AES-encrypted version of the private key

If we look at the private key, we can notice a very strange `pattern` at a certain point:
```
96 e7 52 3f 9a 7b 17 0a 19 2f 94 66 17 bd cc 0d
0c 0e 7c 7e c8 a2 4c 4e 6d e3 9c 6d 1b c2 68 30
96 e7 52 3f 9a 7b 17 0a 19 2f 94 66 17 bd cc 0d
0c 0e 7c 7e c8 a2 4c 4e 6d e3 9c 6d 1b c2 68 30
96 e7 52 3f 9a 7b 17 0a 19 2f 94 66 17 bd cc 0d
0c 0e 7c 7e c8 a2 4c 4e 6d e3 9c 6d 1b c2 68 30
96 e7 52 3f 9a 7b 17 0a 19 2f 94 66 17 bd cc 0d
0c 0e 7c 7e c8 a2 4c 4e 6d e3 9c 6d 1b c2 68 30
96 e7 52 3f 9a 7b 17 0a 19 2f 94 66 17 bd cc 0d
0c 0e 7c 7e c8 a2 4c 4e 6d e3 9c 6d 1b c2 68 30
96 e7 52 3f 9a 7b 17 0a 19 2f 94 66 17 bd cc 0d
0c 0e 7c 7e c8 a2 4c 4e 6d e3 9c 6d 1b c2 68 30
96 e7 52 3f 9a 7b 17 0a 19 2f 94 66 17 bd cc 0d
0c 0e 7c 7e c8 a2 4c 4e 6d e3 9c 6d 1b c2 68 30
96 e7 52 3f 9a 7b 17 0a 19 2f 94 66 17 bd cc 0d
```
This is a classic ECB encryption artifact - identical plaintext blocks encrypted into identical ciphertext blocks

If we reconstruct the private key by the same public key and generating primes of the same size, we can find that the above special data falls into the place where first prime factor which means that the prime factor has to repeating pattern spanning over 2 blocks(32 bytes) in the middle.
So the prime has to be like `X ABCD ABCD ABCD ... Y`

As a result, we could also write this down as `ABCD * 0x10001000... + S` where `S` is the unknown part located in the non-repeating blocks, and `0x10001000...1` has far more zeros
```
# pattern = 0x100000...100000...1
N = p*q
p = k*pattern + S
N = p*q = (k*pattern+S) * q = k*pattern*q + S*q
N - S*q = k*pattern*q
(N-S*q) / pattern = k*q
(N-S*q)/pattern ~= N/pattern - (S*q/pattern)
```
Now we can introduce a polynomial `f(x) = N/pattern - x`, and since we're now looking for `x0 = (S*q/pattern)` the bound for the root is in fact close to `S`

We can look at this via a simple sanity check:
```python
p = getPrime(2048)
k = random.randint(2 ** 255, 2 ** 256)
pattern = 0x10000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001
q = gmpy2.next_prime(k * pattern + random.randint(0, 2 ** 256))
S = q - k * pattern
N = p * q
print(math.log(N // pattern - k * p, 2))
```
This shows us that with this setup the root we woiuld be looking for is about 512 bits long
```python
def solve(N, pattern):
    F.<x> = PolynomialRing(Zmod(N), implementation='NTL')
    poly = x - N//pattern
    roots = poly.small_roots(beta=0.4, X=2**600)
    for root in roots:
        val =  root - N//pattern
        q0 = gcd(N,val)
        if q0 > 1:
            print(int(root).bit_length())
            print('q',q0)
            print('p',int(N)//int(q0))
            print(hex(int(N)//int(q0)))
            return True
```
Anyway, this is not strictly necessary in the task, because the actual root we recovered had 560 bit, so was within the Coppersmith bounds.

There was one more thing to consider - the pattern might be shifted, since the blocks are not perfectly aligned.
We don't really know where is the first `1`, so we check the shifts as well:

```python
pattern = 0x10000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001
for i in range(16):
    N = 864548738332874087668503368831766249570260242783591552090675185261065394078050565610543041932800764724587585870383343251100904921187940519593954644380103508613133721893687769245467054781165129931842935345632471221108475282905047577044998272614999900190070356568926673218272825600985299507924236632515852004699265280255459721713289017451417963625732868682233625418249666192969191571123259131334481738959268675197737845268734505452629162251408183665714593194085000765150594131359155637719565709425013854872777561241631196785845113023038532866885477368063060870336357032800949481193136635548507618719395155108369351135560013249407504681745255774980220938402804576145433072855750609892899681227859840020080049417911764687461353619448605061402921180936683590478280857786258094946429659735653016131876268043249607509143045235827923490215048040840605913760167939925178228075589301790633691254996042457599109896534654922831538681455372034279792686064670317873356145126455426581532494485566559734055837974168777530418933444611498167101313802133643307821986306829084673888064633316469645388738526070397530481627815041169108357108172265337488326979522139084457836177137061191877719132682265381042692814726652081549112958388430260682287769002623
    if solve(N,pattern):
        print(hex(pattern))
        return
    pattern >>=8
```

And running this returns `p`, and `q`, which we can then use to decrypt the flag:

```python
p = 31555720069118467147821203380224688806508163874037062556871239093255339528072891743195624687579532411584859333841089765811499736308991315463091756017090529202299936208689648373141343597991860093978598902926090232992764931582226454250074858177012092591548149291064575730653835010920492247198535167191585166480877445761052166924142883439179965961951576933148558934090755078213363498758285000755039337195455242673921605828911137420067348601000484969826029498761388313806843351409851631342417130602655307496140948184067195777694576593815738040507892091972065716370060935261045921496556097674611235357384656566616433908673
q = 27397528449333398750266387529399849594682216775605225874849547559945466938581310049056423758294428745281988771459564198153711125673814939447341104464740539016255096946065703781298853877488132070586594115004124442717121218952600553960735334894628874273087986471973958189578919842785742959834288220821152546005560279488312797225964835987590602038239664681987623721916034601354242735359390919706918151677300197346402700017376804125322544083323057603601951652908109780754435619135175157568318298834572584611540505862918372984499337203170925029821230664438885207275220250572467711031742903314341377918564015565214188441151
e = 65537
d = modinv(e, (p - 1) * (q - 1))
data = open("flag.enc", 'rb').read()
print(long_to_bytes(pow(bytes_to_long(data), d, p * q)))
```
